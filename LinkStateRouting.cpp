#include "router.hpp"

packet::packet(){
    sequenceNumber = 1;         // sequence number initialized to 1
    TTL = 10;                   /* initialize TTL of each packet to 10,
                                   which implies that 10 is the max number of hops allowed, after which the packet is dropped
                                 */
}

packet::packet(int sequenceNumber){
    this->sequenceNumber = sequenceNumber;
    TTL = 10;        
}    

packet::packet(int routerID, string networkName, int networkCost){
    this->sequenceNumber = sequenceNumber;
    TTL = 10;  
    this->source_RouterID = routerID;
    this->source_NetworkName = networkName;
    this->source_NetworkCost = networkCost;
}    

router::router(int routerID, string networkName, int networkCost){      
    // initialize private variables
    this->routerID = routerID;
    this->networkName = networkName;
    this->networkCost = networkCost;
    
    // initialize networkCostTable
    networkCostTable.push_back(make_pair(networkName, networkCost));
    
    // initialize router state
    this->STATE = "STARTED";
}

void router::fn_addEntryToRoutingTable(string networkName, int linkCost, router *r){
    routingTable.insert(type_routerRoutingTableElement(networkName, make_pair(linkCost, r)));
}

void router::fn_addEntryToNeighboringRoutersTable(string networkName, int linkCost, router *r){
    neighboringRoutersTable.insert(type_routerRoutingTableElement(networkName, make_pair(linkCost, r)));
}
void router::fn_checkTickCounter(){
    if(this->STATE == "STARTED"){
        for(map<string, int>::const_iterator it = tickCounterTable.begin(); it!=tickCounterTable.end(); it++){
            if(abs(this->tickCounter - it->second) == 2){
                string networkName = it->first;
                int tickCount = this->tickCounter - it->second;
                cout<<"\n\nMessage from Network "<<this->networkName<<" : No packets recieved from network "<<it->first<<" since "<<tickCount<<" ticks!!";
                cout<<"\n\nSeems Network "<<it->first<<" is DOWN!\n";
                this->routingTable.erase(networkName);
                this->neighboringRoutersTable.erase(networkName);
                this->tickCounterTable.erase(networkName);
            }
        }
        
        // Output Tick Details
        // cout<<"\n\nCurrent tick counter of network "<<this->networkName<<" : "<<this->tickCounter;
        // cout<<"\n\nTick counter table of network "<<this->networkName<<" : \n";
        // for(map<string, int>::const_iterator it=this->tickCounterTable.begin(); it!=this->tickCounterTable.end(); it++){
        //     cout<<it->first<<"\t"<<it->second<<"\n";
        // }
    }
}

void router::fn_initializeTickCounterTable(){
    for(map<string, int>::iterator it = this->tickCounterTable.begin(); it!=this->tickCounterTable.end(); it++){
        string networkName = it->first;
        tickCounterTable.at(networkName)=0;
    }
}

void router::fn_originatePacket(){
    if(this->STATE=="STOPPED"){
        // do nothing;
    }
    
    else{
        this->tickCounter++;
        
        packet *lsp = new packet(routerID, networkName, networkCost);
        lsp->source_NetworkName = this->networkName;
        lsp->source_RouterID = this->routerID;
        lsp->source_NetworkCost = this->networkCost;
        
        // advertise the router itself in LSP
        lsp->payLoad.insert(type_packetPayloadElement(networkName, make_pair(0, networkCost)));
        
        for(map<string, pair<int, router*> >::const_iterator it = routingTable.begin(); it!=routingTable.end(); it++){
            string networkName = it->first;
            int linkCost = it->second.first;
            int networkCost = -1;

            for(vector<pair<string, int> >::const_iterator x = networkCostTable.begin(); x!=networkCostTable.end(); x++){
                if(x->first == networkName){
                    networkCost = x->second;
                }
            }
            
            lsp->payLoad.insert(type_packetPayloadElement(networkName, make_pair(linkCost, networkCost)));
            
            /*
            // Output LSP generated by generatePacket()
            cout<<"\n\nRouter ID "<<routerID<<" generated LSP: \n";
            for(map<string, pair<int, int> >::const_iterator it = lsp->payLoad.begin(); it!=lsp->payLoad.end(); it++){
                cout<<"\nNetwork Name: "<<it->first<<"\n";
                cout<<"Link Cost: "<<it->second.first<<"\n";
                cout<<"Network Cost: "<<it->second.second<<"\n";
            }
            */ 
        }
        
        try{
            for(map<string, pair<int, router*> >::const_iterator it = neighboringRoutersTable.begin(); it!=neighboringRoutersTable.end(); it++){
                string networkName = it->first;

                router *r = it->second.second;
                r->fn_recievePacket(lsp);
            }
        }catch(exception &e){
            // do nothing
        }
    }  
}
 
void router::fn_recievePacket(packet *p){
    // upon recieveing packet, decrement its TTL by 1
    p->TTL--;
    
    if(p->TTL == 0 || this->STATE=="STOPPED"){
        // if TTL = 0, drop packet
        // No action. No further transmission of this packet.
    }
    
    else{
        try{
            // increment tick counters
            string sourceNetwork = p->source_NetworkName;
            this->tickCounterTable.at(sourceNetwork)++;
        }catch(exception &e){
            // do nothing;
        }
        
        // loop through recieved LSP's data
        vector<string> parsedNetworks;
        vector<string> networksInLSP;
        
        for(map<string, pair<int, int> > ::const_iterator x = p->payLoad.begin(); x!=p->payLoad.end(); x++){            
            networksInLSP.push_back(x->first);
        }    
        
        for(map<string, pair<int, int> > ::const_iterator x = p->payLoad.begin(); x!=p->payLoad.end(); x++){            
        // compare and update routing table
            try{
                for(map<string, pair<int, router*> >::const_iterator y = routingTable.begin(); y!=routingTable.end(); y++){
                    if(x->first == y->first){
                        if(x->first == this->networkName){          // if own network name in LSP, do nothing
                            parsedNetworks.push_back(x->first);                            
                        }
                        else{                                       // if LSP contains information of a network also present in routing table
                                                                    // update the routing table 
                            string networkName = x->first;
                            int linkCost = y->second.first;
                            router *outgoingLink = y->second.second;
                            
                            // erase current entry in router table
                            routingTable.erase(networkName);
                            
                            // add updated entry to router table
                            routingTable.insert(type_routerRoutingTableElement(networkName, make_pair(linkCost, outgoingLink)));
                            parsedNetworks.push_back(x->first);
                            
                        }
                    }                    
                }
            }catch(exception &e){
                //do nothing
            }
        }
        
        // handle information about networks that are present in LSP but not in routing table
        for(map<string, pair<int, int> > ::const_iterator x = p->payLoad.begin(); x!=p->payLoad.end(); x++){            
        // make an entry in the routing table
            if(find(parsedNetworks.begin(), parsedNetworks.end(), x->first) == parsedNetworks.end() && x->first!=this->networkName){
                string LSPSender_networkName = p->source_NetworkName;
                pair<int, router*> pair_LinkCost_OutgoingLink = routingTable.at(LSPSender_networkName);
                int LSPSender_LinkCost = pair_LinkCost_OutgoingLink.first;
                router *LSPSender_OutgoingLink = pair_LinkCost_OutgoingLink.second;
                
                fn_addEntryToRoutingTable(x->first, x->second.first + LSPSender_LinkCost, LSPSender_OutgoingLink);
            }
        }
    }
}

bool isDigit(char c){
    if((int)c>=48 && (int)c<=57){
        return true;
    }
    return false;
}

int main (){
    ifstream inFile;
    vector<char> ReadFileVector; 
    type_GlobalRoutingTable globalRoutingTable;
    int res;

    std::fstream myFile; 
    string inputFilePath;
    
    cout <<"\n\n>>>>>>>>>>>-    WELCOME TO NETWORK ROUTING SIMULATOR    -<<<<"<<"\n\nInput Instructions: Lines containing adjacent router link details must begin with a TAB SPACE";
    cout<<"\nExample:\n\n1 122.123\n\t2 5\n2 123.123\n\t1 5\n";
    cout<<"\nEnter full input DAT file path+name (example- C:\\Users\\User1\\Desktop\\infile.dat):  ";
    cin>>inputFilePath;
    inFile.open(inputFilePath.c_str(), ios::binary); 
    while(!inFile.is_open()){
        cout<<"\n\nFile open failed. Try again!";
        cout<<"\n\nEnter full input DAT file path+name (example- C:\\Users\\User1\\Desktop\\infile.dat):  ";
        cin>>inputFilePath;
        inFile.open(inputFilePath.c_str(), ios::binary); 
    }

    // get length of input file
    inFile.seekg(0, std::ios::end);
    size_t file_size_in_byte = inFile.tellg();
    ReadFileVector.resize(file_size_in_byte);
    inFile.seekg(0, std::ios::beg);
    inFile.read(&ReadFileVector[0], file_size_in_byte);
    
    inFile.close();
    
    // Normalize input vector
    ReadFileVector.at(ReadFileVector.size()-1) = '\n';
    
    // print contents of read input file
    cout<<"\n\nYou have input following configuration --\n\n";
    for (vector<char>::const_iterator i = ReadFileVector.begin(); i != ReadFileVector.end(); ++i){
        cout << *i;
    }
    
    // parse contents of read input file (only parse router config, network config (such as adjacency) to be parsed in next step
    for (vector<char>::const_iterator i = ReadFileVector.begin(); i != ReadFileVector.end(); ++i){
        if(isDigit(*i)){
            while(i != ReadFileVector.end() && *i != '\n'){         // parse entire line (until '\n' is encountered)
                int routerID = 0;
                string networkName;
                int networkCost = 0;
                
                while(*i != ' ' && i != ReadFileVector.end()){                    // 1 - get router ID
                    routerID = routerID*10 + (*i - '0');
                    i++;
                }
                
                while(*i == ' ' && i != ReadFileVector.end()){                    // 2 - ignore spaces between router ID and network name
                    i++;
                }
                
                while(*i != ' ' && *i != '\n' && i != ReadFileVector.end()){      // 3 - get network name
                    if(*i!='\r'){
                        networkName = networkName + (*i);
                    }
                    i++;
                }

                while(*i == ' ' && i != ReadFileVector.end()){                    // 4 - ignore spaces between network name and network cost
                    i++;
                }
                
                while(*i != ' ' && *i != '\n' && i != ReadFileVector.end()){      // 5 - get network cost
                    if(*i=='\r'){
                        i++;
                    }
                    else{
                        networkCost = networkCost*10 + (*i - '0');
                        i++;
                    }
                }
                
                // Print configuration of all initialized routers
                cout<<"\n\nInitialized Router with Config ---\n\nRouter ID: "<<routerID;
                cout<<"\nNetwork Name: "<<networkName;
                if(networkCost == 0){       // if no network cost specified in input file, assume default value = 1 
                    networkCost = 1;
                }
                cout<<"\nNetwork Cost: "<<networkCost;
                // Sleep(500);
                
                router *r = new router(routerID, networkName, networkCost);
                
                globalRoutingTable.insert(type_GlobalRoutingReference(routerID, r));  
            }            
        }
        
        if(*i == '\t'){             
            while(i != ReadFileVector.end() && *i != '\n'){         // parse entire line (until '\n' is encountered)
                i++;
                continue;
            }            
        }

        else{           // if any character other than digits 0-9, white space, \t, or \n is encounterd, ignore it
            continue;
        }
    }

    // parse contents of read input file (only parse network config (such as adjacency)), router config already parsed in prev step
    for (vector<char>::const_iterator i = ReadFileVector.begin(); i != ReadFileVector.end(); ++i){
        int routerID, linkCost = 0;
        if(isDigit(*i)){
            routerID = 0;
            
            while(*i != ' ' && i != ReadFileVector.end()){           // 1 - get router ID
                routerID = routerID*10 + (*i - '0');
                i++;
            }
  
            while(i != ReadFileVector.end() && *i != '\n'){         // parse entire line (until '\n' is encountered)
                i++;
            }
            
            i++;                                                    // increment iterator to character after new line
        }
        
        if(*i == '\t'){             // network config (indented in infile.dat) to be parsed in later step
            while(i != ReadFileVector.end() && *i != '\n'){         // parse entire line (until '\n' is encountered)
                i++;
                
                int adjacentRouterID = 0;
                int linkCost = 0;
                
                while(*i != ' ' && *i != '\r' && i != ReadFileVector.end()){      // 2 - get adjacent router ID
                    adjacentRouterID = adjacentRouterID*10 + (*i - '0');
                    i++;
                }
                
                while(*i == ' ' && i != ReadFileVector.end()){                    // 3 - ignore spaces between adjacent router ID and link cost
                    i++;
                }
                
                while(*i != ' '&& *i != '\n' && i != ReadFileVector.end()){       // 4 - get link cost
                    if(*i == '\r' && i+1!=ReadFileVector.end()){
                        i++;
                    }
                    else{
                        linkCost = linkCost*10 + (*i - '0');
                        i++;
                    }
                }
                
                if(linkCost == 0){       // if no link cost specified in input file, assume default value = 1 
                    linkCost = 1;
                }
                
                try{
                    router *r = globalRoutingTable.at(routerID);
                    router *r_adjacent = globalRoutingTable.at(adjacentRouterID);
                    string r_adjacentNetworkName = r_adjacent->networkName;
                
                    r->fn_addEntryToRoutingTable(r_adjacentNetworkName, linkCost, r_adjacent);
                    r->fn_addEntryToNeighboringRoutersTable(r_adjacentNetworkName, linkCost, r_adjacent);
                    r->tickCounterTable.insert(make_pair(r_adjacentNetworkName, 0));
                }catch(exception &e){
                    cout<<"\n\nERROR: Invalid user input. Router ID "<<adjacentRouterID<<", declared as adjacent to "<<routerID<<", does not have a network configuration specified in input file!!";
                    cout<<"\n\nPlease correct the input file config, then restart program. Exiting ...";
                    Sleep(8000);
                    exit(0);
                }
                
                /*
                cout<<"\n\nPrinting adjacent router information for router "<<routerID<<" ---\n";
                cout<<"Adjacent router ID: "<<adjacentRouterID<<"       Adjacent router link: "<<r_adjacent;
                 */
            }
        }        
        
        else{           // if any character other than digits 0-9, white space, \t, or \n is encounterd, ignore it
            continue;
        }
    }

    /*
    // Displaying contents of global routing table
    cout<<"\n\nPrinting global routing table --- \n\n";
    for(map<int, router*>::const_iterator it = globalRoutingTable.begin(); it!=globalRoutingTable.end(); it++){
        cout<<it->first<<"     "<<it->second<<"\n";
    }
    
    Sleep(3000);
    
    //Displaying public data of router objects
    cout<<"\n\nPrinting information of router ID 0 ---";
    router *r = globalRoutingTable.at(0);
    cout<<"\n\nRouter ID:  "<<r->routerID;
    cout<<"\nNetwork Name:  "<<r->networkName;
    cout<<"\nNetwork Cost:  "<<r->networkCost;
    Sleep(2000);
    */
    
    char userInput_Choice;
    do{
        cout<<"\n\n<**>>> ---- Network Analysis and Configuration Menu ---- <<<**> \n\n1. Print routing table (P)";
        cout<<"\n2. Start router (T)\n3. Stop router (S)\n4. Continue (C)\n\nEnter choice:  ";
        cin>>userInput_Choice;
        userInput_Choice = tolower(userInput_Choice);
        
        switch(userInput_Choice){
            case 'p': {
                            cout<<"\n\n[Print routing table] Enter Router ID:  ";
            
                            int userInput_RouterID;  
                            cin>>userInput_RouterID;
                            
                            router* userInput_Router;
                            try{
                                userInput_Router = globalRoutingTable.at(userInput_RouterID);
                            }catch(out_of_range& e){
                                cout<<"\n\nERROR: Invalid router ID entered. No router with this ID exists!!";
                                break;
                            }
                            cout<<"\nRouter Table for router "<<userInput_RouterID<<"  ---\n\nNetwork name\tLink cost\tOutgoing Link\n\n";
                            
                            for(map<string, pair<int, router*> >::const_iterator it = userInput_Router->routingTable.begin(); it!=userInput_Router->routingTable.end(); it++){
                                cout<<it->first<<"\t"<<it->second.first<<"\t"<<it->second.second<<"\n";
                            }
        
                            break;
                      }
                      
            case 's': {
                            cout<<"\n\n[Stop router] Enter Router ID:  ";
                            int userInput_RouterID;
                            cin>>userInput_RouterID;
                            
                            router* userInput_Router;
                            try{
                                userInput_Router = globalRoutingTable.at(userInput_RouterID);
                            }
                            catch(out_of_range& e){
                                cout<<"\n\nERROR: Invalid router ID entered. No router with this ID exists!!";
                                break;
                            }
                            userInput_Router->STATE = "STOPPED";
                            
                            cout<<"Router "<<userInput_RouterID<<" is now STOPPED";
                            Sleep(1500);
                            break;
                      }

            case 't': {
                            cout<<"\n\n[Start router] Enter Router ID:  ";
                            int userInput_RouterID;
                            cin>>userInput_RouterID;
                            
                            router* userInput_Router;
                            try{
                                userInput_Router = globalRoutingTable.at(userInput_RouterID);
                            }
                            catch(out_of_range& e){
                                cout<<"\n\nERROR: Invalid router ID entered. No router with this ID exists!!";
                                break;
                            }
                            userInput_Router->STATE = "STARTED";
                            
                            cout<<"\n\nRouter "<<userInput_RouterID<<" is now STARTED.\n";
							
							try{
								for(map<int, router*>::const_iterator it = globalRoutingTable.begin(); it!=globalRoutingTable.end(); it++){
                                   router* r = it->second;
                                   for(int i=0; i<2; i++){
                                        r->fn_originatePacket();
                                   }
                                   r->tickCounter = 0;
                                   r->fn_initializeTickCounterTable();
								}
                            }catch(exception &e){
                                // do nothing
                            }
                            Sleep(1500);
                      }
                      
            case 'c': { // iterate through all router objects and invoke their originatePacket and checkTickCounter functions
                            try{
                                for(map<int, router*>::const_iterator it = globalRoutingTable.begin(); it!=globalRoutingTable.end(); it++){
                                    router* r = it->second;
                                    r->fn_originatePacket();
                                }
                            }catch(exception &e){
                                // do nothing
                            }

                            for(map<int, router*>::const_iterator it = globalRoutingTable.begin(); it!=globalRoutingTable.end(); it++){
                                // for every network in router's routing table, evaluate tick count
                                router* r = it->second;
                                r->fn_checkTickCounter();
                            }
                
                            break;
                      }
                      
            case 'q': break;

            default: cout<<"\n\nInvalid choice entered!! Please enter one of following choices: P/S/T/Q:  ";
                     break;
        }
        
    }while(userInput_Choice!='Q' && userInput_Choice!='q');
    
    cout<<"\n\nExiting program ...";
    Sleep(3000);
    
    return 0;
}